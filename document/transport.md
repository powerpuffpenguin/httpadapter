# 傳輸層

這裏定義了傳輸層的詳細定義，除非特別說明否則涉及到的二進制數字都使用大端序


* [hello](#hello)
* [ping](#ping)
* [pong](#pong)
* [create](#create)
* [close](#close)
* [write](#write)
* [confirm](#confirm)

# hello

在 tcp-chain 中，客戶端需要首先向服務器發送一個 hello 消息，服務器同樣返回一個 hello 消息，如果服務器返回的 hello 中沒有包含錯誤則表示可以進行後續通信，否則服務器當前無法與客戶端通信，客戶端應該關閉 tcp-chain 並與服務器管理員聯繫尋求解決方案

客戶端發送的 hello 消息如下

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   flag        |   0 |     11  |   協議標識用於服務器區分底層協議，固定字符串 'httpadapter' |
|   window  |   11   |  2   |   客戶端 channel 數據窗口大小    |
|   len         |   13 |    2 |     version 字段的長度  | 
|   version|    15 |    len字段定義  |  以英文逗號分隔的 客戶端版本 例如 '1.0' 或 '1.1,0.9'

version 這個字段是客戶端告訴服務器自己支持的協議版本，目前的有效值是 1.0，服務器將選擇一個自己支持的版本以 hello 消息返回給客戶端此後客戶端需要使用此版本協議與服務器通信，否則服務器會在 hello 消息中攜帶錯誤消息

> 客戶端應該在 version 先寫首推的協議版本，後寫兼容協議版本，因爲服務器會使用第一個匹配的協議版本，與客戶端通信

服務器返回的 hello 消息如下

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   flag   |   0 |  11  |   協議標識用於服務器區分底層協議，固定字符串 'httpadapter' |
|   code |  11 |    1   |   錯誤代碼，如果爲0表示沒有錯誤可以繼續後續通信，否則客戶端應該停止通信並關閉 tcp-chain     |
|   window  |   12  |   2   |   服務器 channel 數據窗口大小   |
|   len     |   14  |   2   |  message 字段長度 |
|   message   | 16  |  len 字段定義 |  如果 code 爲0，此值是服務器選擇的協議版本字符串(例如 '1.0')，否則是錯誤信息的描述字符串 |

下面列表列舉了 code 可能的值
| code 值 | 含義 |
| --- | --- |
| 0 | 成功 |
| 1 | 協議未知 |
| 2 | 沒有匹配的 協議版本 |
| 3 | 服務器繁忙請稍後再重試 |
| 4 | 服務器發生了非預期錯誤，無法提供服務|
| 5 | window 值無效|

# ping

服務器和客戶端之間隨時可以發送 ping 指令用於檢查連接或者保持心跳，ping 是可選的，其定義如下

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   command   |   0 |  1  |   固定爲 1 |

# pong

服務器和客戶端可以向對方發送一個 pong 指令，對方將在收到後原樣返回，這通常可以用來估算網路兩端的延遲情況

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   command   |   0 |  1  |   固定爲 2 |
|   id  |   1  |    4   |   流水id，每次發送後應該自動 +2，服務器從 1 開始，客戶端從 0 開始|

id 流水用於區分響應 pong，響應的 pong 並不一定按照發送順序返回，例如客戶端第一次發送 pong 的 id 爲 0，在服務器響應 pong 之前發送了第二次 pong 的 id 爲 2，服務器有可能會先返回 pong 2 再返回 pong 0

客戶端主動發送的 id 從 0開始，客服主動發送的 id 從 1 開始。所以客戶端主動發送的 pong id 都是偶數，客戶端響應的 pong id 都是奇數。同理服務器主動發送的 pong id 都是奇數，服務器響應的 pong id 都是偶數。

# create

客戶端可以向服務器發送 create 指令來創建一個 channel

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   command   |   0 |  1  |   固定爲 3 |
|   id  |   1  |    8   |   channel 的唯一 id|

> 客戶端可以使用一個自增加的 uint64 作爲 id，每次創建後將其 +1，服務器對 id 沒有額外要求，只需要客戶端保證活躍的 channel id 不重複即可

服務器在創建好 channel 後會返回如下響應

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   command   |   0 |  1  |   固定爲 3 |
|   id  |   1  |    8   |   客戶端發送來的 id |
|   code  |   9  |    1   |   服務器處理狀態碼 |

下面列表列舉了 code 可能的值，只有當 code 爲 0 時才能使用此 channel 進行通信，其它值客戶端應該釋放掉資源

| code 值 | 含義 |
| --- | --- |
| 0 | 成功，channel 已經準備好工作 |
| 1 | 已經存在一個相同的 channel id，無法創建 id |
| 2 | 服務器達到最大 channel 上限，無法創建更多 channel，可以在關閉掉一些 channel 後重試 |

# close

客戶端和服務器都可以向對方方式 close 指定來告訴對方應該關閉某個 channel，當收到 close 指令時應該關閉 channel 並釋放資源，如果指定的 channel 不存在則應該直接忽略此消息

一個 channel 關閉後就能繼續發送數據，但它可能還會收到來自對方發送來的數據，因爲這些數據可能則被緩存在網路之中，即在 close 之前已經存在與網路中未來得及處理的數據(對於這部分的數據可以簡單的直接將其丟棄即可)

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   command   |   0 |  1  |   固定爲 4 |
|   id  |   1  |    8   |   要關閉的 channel id |

收到 close 指令後無需進行回覆

# write

write 指令用於雙方向 channel 寫入數據，注意 channel 的 window 代表了對方可以無阻塞處理的數據大小，發送方應該依據自己 write 的數據大小以及對方發送的 confirm 來維護 window，當 window 爲 0  時就不能再向 channel 寫入數據，此時上層的 Write/Send 函數應該阻塞或者返回錯誤

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   command   |   0 |  1  |   固定爲 5 |
|   id  |   1  |    8   |   要寫入的 channel id |
|   len |   9   |   2   |  要寫入的數據大小  |
|   data |   11   |   由 len 字段確定   |  要寫入的數據  |


# confirm

confirm 是極爲重要的一個指令，每個 channel 都知道對方 channel 的初始 window 大小，這代值代表對方能能夠無阻塞處理的數據大小，當向對方發送了 window 大小的數據且未被確認後，就不能在向 channel 發送數據(此時應該阻塞 channel 的 Write/Send 函數或使用函數返回錯誤)。需要等待對方發送 confirm 來通知已處理的數據使用 window 能夠有空閒數據可以繼續發送。

最簡單的實現方法是在 channel 收到 write 指令的數據並處理完成後直接向對方發送一個 confirm 消息以通知對方調整 window 可用大小。一些高效的實現則會通過算法合併同個或多個 channel 的 confirm 消息一起發送

| 字段 | 偏移 | 字節 | 含義 |
|--- |--- |---|---|
|   command   |   0 |  1  |   固定爲 6 |
|   id  |   1  |    8   |   要確認的 channel id |
|   size  |   9  |    4   |   這是一個 uint32 值，表示確認多大 window數據被處理 |